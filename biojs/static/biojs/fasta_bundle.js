/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var Fasta = __webpack_require__(1);
	
	//Define fasta requirejs module
	window.define('fasta', function(){
	  console.log("Fasta requirejs module defined");
	  return Fasta;
	});


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var Fasta, GenericReader;
	
	  GenericReader = __webpack_require__(2);
	
	  Fasta = __webpack_require__(14);
	
	  module.exports = Fasta;
	
	  GenericReader.mixin(Fasta);
	
	}).call(this);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var GenericReader;
	
	var xhr = __webpack_require__(3);
	var vow = __webpack_require__(11);
	
	module.exports = GenericReader = (function() {
	  function GenericReader() {}
	
	  // returns a promise if callback is undefined
	  GenericReader.read = function(url, callback) {
	    var onret;
	    onret = (function(_this) {
	      return function(err, response, text) {
	        return GenericReader._onRetrieval(err, text, callback, _this);
	      };
	    })(this);
	
	    if(typeof callback === "undefined"){
	      var prom = vow.defer();
	      callback = function(err, res){
	        if(err){
	          prom.reject(err);
	        }else{
	          prom.resolve(res);
	        }
	      };
	      xhr(url, onret);
	      return prom.promise();
	    }else{
	      return xhr(url, onret);
	    }
	  };
	
	  GenericReader._onRetrieval = function(err, text, callback, _this) {
	    var rText;
	    if(typeof err !== "undefined"){
	      rText = _this.parse(text);
	    }
	    return callback.call(_this, err, rText);
	  };
	
	  // provide a convenient shortcut to inherit
	  GenericReader.extend = function(obj, statics){
	    return extend(GenericReader, obj, statics); 
	  };
	  // Mixin utility
	  GenericReader.mixin = function(proto) {
	    var exports = ['read'];
	    if(typeof proto !== "object"){
	      proto = proto.prototype;
	    }
	    exports.forEach(function(name) {
	      proto[name] = GenericReader[name];
	    }, this);
	    return proto;
	  };
	
	  return GenericReader;
	
	})();


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var window = __webpack_require__(4)
	var once = __webpack_require__(5)
	var isFunction = __webpack_require__(6)
	var parseHeaders = __webpack_require__(7)
	var xtend = __webpack_require__(10)
	
	module.exports = createXHR
	createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
	createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest
	
	forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
	    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
	        options = initParams(uri, options, callback)
	        options.method = method.toUpperCase()
	        return _createXHR(options)
	    }
	})
	
	function forEachArray(array, iterator) {
	    for (var i = 0; i < array.length; i++) {
	        iterator(array[i])
	    }
	}
	
	function isEmpty(obj){
	    for(var i in obj){
	        if(obj.hasOwnProperty(i)) return false
	    }
	    return true
	}
	
	function initParams(uri, options, callback) {
	    var params = uri
	
	    if (isFunction(options)) {
	        callback = options
	        if (typeof uri === "string") {
	            params = {uri:uri}
	        }
	    } else {
	        params = xtend(options, {uri: uri})
	    }
	
	    params.callback = callback
	    return params
	}
	
	function createXHR(uri, options, callback) {
	    options = initParams(uri, options, callback)
	    return _createXHR(options)
	}
	
	function _createXHR(options) {
	    var callback = options.callback
	    if(typeof callback === "undefined"){
	        throw new Error("callback argument missing")
	    }
	    callback = once(callback)
	
	    function readystatechange() {
	        if (xhr.readyState === 4) {
	            loadFunc()
	        }
	    }
	
	    function getBody() {
	        // Chrome with requestType=blob throws errors arround when even testing access to responseText
	        var body = undefined
	
	        if (xhr.response) {
	            body = xhr.response
	        } else if (xhr.responseType === "text" || !xhr.responseType) {
	            body = xhr.responseText || xhr.responseXML
	        }
	
	        if (isJson) {
	            try {
	                body = JSON.parse(body)
	            } catch (e) {}
	        }
	
	        return body
	    }
	
	    var failureResponse = {
	                body: undefined,
	                headers: {},
	                statusCode: 0,
	                method: method,
	                url: uri,
	                rawRequest: xhr
	            }
	
	    function errorFunc(evt) {
	        clearTimeout(timeoutTimer)
	        if(!(evt instanceof Error)){
	            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
	        }
	        evt.statusCode = 0
	        callback(evt, failureResponse)
	    }
	
	    // will load the data & process the response in a special response object
	    function loadFunc() {
	        if (aborted) return
	        var status
	        clearTimeout(timeoutTimer)
	        if(options.useXDR && xhr.status===undefined) {
	            //IE8 CORS GET successful response doesn't have a status field, but body is fine
	            status = 200
	        } else {
	            status = (xhr.status === 1223 ? 204 : xhr.status)
	        }
	        var response = failureResponse
	        var err = null
	
	        if (status !== 0){
	            response = {
	                body: getBody(),
	                statusCode: status,
	                method: method,
	                headers: {},
	                url: uri,
	                rawRequest: xhr
	            }
	            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
	                response.headers = parseHeaders(xhr.getAllResponseHeaders())
	            }
	        } else {
	            err = new Error("Internal XMLHttpRequest Error")
	        }
	        callback(err, response, response.body)
	
	    }
	
	    var xhr = options.xhr || null
	
	    if (!xhr) {
	        if (options.cors || options.useXDR) {
	            xhr = new createXHR.XDomainRequest()
	        }else{
	            xhr = new createXHR.XMLHttpRequest()
	        }
	    }
	
	    var key
	    var aborted
	    var uri = xhr.url = options.uri || options.url
	    var method = xhr.method = options.method || "GET"
	    var body = options.body || options.data || null
	    var headers = xhr.headers = options.headers || {}
	    var sync = !!options.sync
	    var isJson = false
	    var timeoutTimer
	
	    if ("json" in options) {
	        isJson = true
	        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
	        if (method !== "GET" && method !== "HEAD") {
	            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
	            body = JSON.stringify(options.json)
	        }
	    }
	
	    xhr.onreadystatechange = readystatechange
	    xhr.onload = loadFunc
	    xhr.onerror = errorFunc
	    // IE9 must have onprogress be set to a unique function.
	    xhr.onprogress = function () {
	        // IE must die
	    }
	    xhr.ontimeout = errorFunc
	    xhr.open(method, uri, !sync, options.username, options.password)
	    //has to be after open
	    if(!sync) {
	        xhr.withCredentials = !!options.withCredentials
	    }
	    // Cannot set timeout with sync request
	    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
	    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
	    if (!sync && options.timeout > 0 ) {
	        timeoutTimer = setTimeout(function(){
	            aborted=true//IE9 may still call readystatechange
	            xhr.abort("timeout")
	            var e = new Error("XMLHttpRequest timeout")
	            e.code = "ETIMEDOUT"
	            errorFunc(e)
	        }, options.timeout )
	    }
	
	    if (xhr.setRequestHeader) {
	        for(key in headers){
	            if(headers.hasOwnProperty(key)){
	                xhr.setRequestHeader(key, headers[key])
	            }
	        }
	    } else if (options.headers && !isEmpty(options.headers)) {
	        throw new Error("Headers cannot be set on an XDomainRequest object")
	    }
	
	    if ("responseType" in options) {
	        xhr.responseType = options.responseType
	    }
	
	    if ("beforeSend" in options &&
	        typeof options.beforeSend === "function"
	    ) {
	        options.beforeSend(xhr)
	    }
	
	    xhr.send(body)
	
	    return xhr
	
	
	}
	
	function noop() {}


/***/ },
/* 4 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {if (typeof window !== "undefined") {
	    module.exports = window;
	} else if (typeof global !== "undefined") {
	    module.exports = global;
	} else if (typeof self !== "undefined"){
	    module.exports = self;
	} else {
	    module.exports = {};
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = once
	
	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })
	})
	
	function once (fn) {
	  var called = false
	  return function () {
	    if (called) return
	    called = true
	    return fn.apply(this, arguments)
	  }
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = isFunction
	
	var toString = Object.prototype.toString
	
	function isFunction (fn) {
	  var string = toString.call(fn)
	  return string === '[object Function]' ||
	    (typeof fn === 'function' && string !== '[object RegExp]') ||
	    (typeof window !== 'undefined' &&
	     // IE8 and below
	     (fn === window.setTimeout ||
	      fn === window.alert ||
	      fn === window.confirm ||
	      fn === window.prompt))
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var trim = __webpack_require__(8)
	  , forEach = __webpack_require__(9)
	  , isArray = function(arg) {
	      return Object.prototype.toString.call(arg) === '[object Array]';
	    }
	
	module.exports = function (headers) {
	  if (!headers)
	    return {}
	
	  var result = {}
	
	  forEach(
	      trim(headers).split('\n')
	    , function (row) {
	        var index = row.indexOf(':')
	          , key = trim(row.slice(0, index)).toLowerCase()
	          , value = trim(row.slice(index + 1))
	
	        if (typeof(result[key]) === 'undefined') {
	          result[key] = value
	        } else if (isArray(result[key])) {
	          result[key].push(value)
	        } else {
	          result[key] = [ result[key], value ]
	        }
	      }
	  )
	
	  return result
	}

/***/ },
/* 8 */
/***/ function(module, exports) {

	
	exports = module.exports = trim;
	
	function trim(str){
	  return str.replace(/^\s*|\s*$/g, '');
	}
	
	exports.left = function(str){
	  return str.replace(/^\s*/, '');
	};
	
	exports.right = function(str){
	  return str.replace(/\s*$/, '');
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(6)
	
	module.exports = forEach
	
	var toString = Object.prototype.toString
	var hasOwnProperty = Object.prototype.hasOwnProperty
	
	function forEach(list, iterator, context) {
	    if (!isFunction(iterator)) {
	        throw new TypeError('iterator must be a function')
	    }
	
	    if (arguments.length < 3) {
	        context = this
	    }
	    
	    if (toString.call(list) === '[object Array]')
	        forEachArray(list, iterator, context)
	    else if (typeof list === 'string')
	        forEachString(list, iterator, context)
	    else
	        forEachObject(list, iterator, context)
	}
	
	function forEachArray(array, iterator, context) {
	    for (var i = 0, len = array.length; i < len; i++) {
	        if (hasOwnProperty.call(array, i)) {
	            iterator.call(context, array[i], i, array)
	        }
	    }
	}
	
	function forEachString(string, iterator, context) {
	    for (var i = 0, len = string.length; i < len; i++) {
	        // no such thing as a sparse string.
	        iterator.call(context, string.charAt(i), i, string)
	    }
	}
	
	function forEachObject(object, iterator, context) {
	    for (var k in object) {
	        if (hasOwnProperty.call(object, k)) {
	            iterator.call(context, object[k], k, object)
	        }
	    }
	}


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = extend
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process) {/**
	 * @module vow
	 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
	 * @version 0.4.12
	 * @license
	 * Dual licensed under the MIT and GPL licenses:
	 *   * http://www.opensource.org/licenses/mit-license.php
	 *   * http://www.gnu.org/licenses/gpl.html
	 */
	
	(function(global) {
	
	var undef,
	    nextTick = (function() {
	        var fns = [],
	            enqueueFn = function(fn) {
	                return fns.push(fn) === 1;
	            },
	            callFns = function() {
	                var fnsToCall = fns, i = 0, len = fns.length;
	                fns = [];
	                while(i < len) {
	                    fnsToCall[i++]();
	                }
	            };
	
	        if(typeof setImmediate === 'function') { // ie10, nodejs >= 0.10
	            return function(fn) {
	                enqueueFn(fn) && setImmediate(callFns);
	            };
	        }
	
	        if(typeof process === 'object' && process.nextTick) { // nodejs < 0.10
	            return function(fn) {
	                enqueueFn(fn) && process.nextTick(callFns);
	            };
	        }
	
	        var MutationObserver = global.MutationObserver || global.WebKitMutationObserver; // modern browsers
	        if(MutationObserver) {
	            var num = 1,
	                node = document.createTextNode('');
	
	            new MutationObserver(callFns).observe(node, { characterData : true });
	
	            return function(fn) {
	                enqueueFn(fn) && (node.data = (num *= -1));
	            };
	        }
	
	        if(global.postMessage) {
	            var isPostMessageAsync = true;
	            if(global.attachEvent) {
	                var checkAsync = function() {
	                        isPostMessageAsync = false;
	                    };
	                global.attachEvent('onmessage', checkAsync);
	                global.postMessage('__checkAsync', '*');
	                global.detachEvent('onmessage', checkAsync);
	            }
	
	            if(isPostMessageAsync) {
	                var msg = '__promise' + Math.random() + '_' +new Date,
	                    onMessage = function(e) {
	                        if(e.data === msg) {
	                            e.stopPropagation && e.stopPropagation();
	                            callFns();
	                        }
	                    };
	
	                global.addEventListener?
	                    global.addEventListener('message', onMessage, true) :
	                    global.attachEvent('onmessage', onMessage);
	
	                return function(fn) {
	                    enqueueFn(fn) && global.postMessage(msg, '*');
	                };
	            }
	        }
	
	        var doc = global.document;
	        if('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
	            var createScript = function() {
	                    var script = doc.createElement('script');
	                    script.onreadystatechange = function() {
	                        script.parentNode.removeChild(script);
	                        script = script.onreadystatechange = null;
	                        callFns();
	                };
	                (doc.documentElement || doc.body).appendChild(script);
	            };
	
	            return function(fn) {
	                enqueueFn(fn) && createScript();
	            };
	        }
	
	        return function(fn) { // old browsers
	            enqueueFn(fn) && setTimeout(callFns, 0);
	        };
	    })(),
	    throwException = function(e) {
	        nextTick(function() {
	            throw e;
	        });
	    },
	    isFunction = function(obj) {
	        return typeof obj === 'function';
	    },
	    isObject = function(obj) {
	        return obj !== null && typeof obj === 'object';
	    },
	    toStr = Object.prototype.toString,
	    isArray = Array.isArray || function(obj) {
	        return toStr.call(obj) === '[object Array]';
	    },
	    getArrayKeys = function(arr) {
	        var res = [],
	            i = 0, len = arr.length;
	        while(i < len) {
	            res.push(i++);
	        }
	        return res;
	    },
	    getObjectKeys = Object.keys || function(obj) {
	        var res = [];
	        for(var i in obj) {
	            obj.hasOwnProperty(i) && res.push(i);
	        }
	        return res;
	    },
	    defineCustomErrorType = function(name) {
	        var res = function(message) {
	            this.name = name;
	            this.message = message;
	        };
	
	        res.prototype = new Error();
	
	        return res;
	    },
	    wrapOnFulfilled = function(onFulfilled, idx) {
	        return function(val) {
	            onFulfilled.call(this, val, idx);
	        };
	    };
	
	/**
	 * @class Deferred
	 * @exports vow:Deferred
	 * @description
	 * The `Deferred` class is used to encapsulate newly-created promise object along with functions that resolve, reject or notify it.
	 */
	
	/**
	 * @constructor
	 * @description
	 * You can use `vow.defer()` instead of using this constructor.
	 *
	 * `new vow.Deferred()` gives the same result as `vow.defer()`.
	 */
	var Deferred = function() {
	    this._promise = new Promise();
	};
	
	Deferred.prototype = /** @lends Deferred.prototype */{
	    /**
	     * Returns the corresponding promise.
	     *
	     * @returns {vow:Promise}
	     */
	    promise : function() {
	        return this._promise;
	    },
	
	    /**
	     * Resolves the corresponding promise with the given `value`.
	     *
	     * @param {*} value
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer(),
	     *     promise = defer.promise();
	     *
	     * promise.then(function(value) {
	     *     // value is "'success'" here
	     * });
	     *
	     * defer.resolve('success');
	     * ```
	     */
	    resolve : function(value) {
	        this._promise.isResolved() || this._promise._resolve(value);
	    },
	
	    /**
	     * Rejects the corresponding promise with the given `reason`.
	     *
	     * @param {*} reason
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer(),
	     *     promise = defer.promise();
	     *
	     * promise.fail(function(reason) {
	     *     // reason is "'something is wrong'" here
	     * });
	     *
	     * defer.reject('something is wrong');
	     * ```
	     */
	    reject : function(reason) {
	        if(this._promise.isResolved()) {
	            return;
	        }
	
	        if(vow.isPromise(reason)) {
	            reason = reason.then(function(val) {
	                var defer = vow.defer();
	                defer.reject(val);
	                return defer.promise();
	            });
	            this._promise._resolve(reason);
	        }
	        else {
	            this._promise._reject(reason);
	        }
	    },
	
	    /**
	     * Notifies the corresponding promise with the given `value`.
	     *
	     * @param {*} value
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer(),
	     *     promise = defer.promise();
	     *
	     * promise.progress(function(value) {
	     *     // value is "'20%'", "'40%'" here
	     * });
	     *
	     * defer.notify('20%');
	     * defer.notify('40%');
	     * ```
	     */
	    notify : function(value) {
	        this._promise.isResolved() || this._promise._notify(value);
	    }
	};
	
	var PROMISE_STATUS = {
	    PENDING   : 0,
	    RESOLVED  : 1,
	    FULFILLED : 2,
	    REJECTED  : 3
	};
	
	/**
	 * @class Promise
	 * @exports vow:Promise
	 * @description
	 * The `Promise` class is used when you want to give to the caller something to subscribe to,
	 * but not the ability to resolve or reject the deferred.
	 */
	
	/**
	 * @constructor
	 * @param {Function} resolver See https://github.com/domenic/promises-unwrapping/blob/master/README.md#the-promise-constructor for details.
	 * @description
	 * You should use this constructor directly only if you are going to use `vow` as DOM Promises implementation.
	 * In other case you should use `vow.defer()` and `defer.promise()` methods.
	 * @example
	 * ```js
	 * function fetchJSON(url) {
	 *     return new vow.Promise(function(resolve, reject, notify) {
	 *         var xhr = new XMLHttpRequest();
	 *         xhr.open('GET', url);
	 *         xhr.responseType = 'json';
	 *         xhr.send();
	 *         xhr.onload = function() {
	 *             if(xhr.response) {
	 *                 resolve(xhr.response);
	 *             }
	 *             else {
	 *                 reject(new TypeError());
	 *             }
	 *         };
	 *     });
	 * }
	 * ```
	 */
	var Promise = function(resolver) {
	    this._value = undef;
	    this._status = PROMISE_STATUS.PENDING;
	
	    this._fulfilledCallbacks = [];
	    this._rejectedCallbacks = [];
	    this._progressCallbacks = [];
	
	    if(resolver) { // NOTE: see https://github.com/domenic/promises-unwrapping/blob/master/README.md
	        var _this = this,
	            resolverFnLen = resolver.length;
	
	        resolver(
	            function(val) {
	                _this.isResolved() || _this._resolve(val);
	            },
	            resolverFnLen > 1?
	                function(reason) {
	                    _this.isResolved() || _this._reject(reason);
	                } :
	                undef,
	            resolverFnLen > 2?
	                function(val) {
	                    _this.isResolved() || _this._notify(val);
	                } :
	                undef);
	    }
	};
	
	Promise.prototype = /** @lends Promise.prototype */ {
	    /**
	     * Returns the value of the fulfilled promise or the reason in case of rejection.
	     *
	     * @returns {*}
	     */
	    valueOf : function() {
	        return this._value;
	    },
	
	    /**
	     * Returns `true` if the promise is resolved.
	     *
	     * @returns {Boolean}
	     */
	    isResolved : function() {
	        return this._status !== PROMISE_STATUS.PENDING;
	    },
	
	    /**
	     * Returns `true` if the promise is fulfilled.
	     *
	     * @returns {Boolean}
	     */
	    isFulfilled : function() {
	        return this._status === PROMISE_STATUS.FULFILLED;
	    },
	
	    /**
	     * Returns `true` if the promise is rejected.
	     *
	     * @returns {Boolean}
	     */
	    isRejected : function() {
	        return this._status === PROMISE_STATUS.REJECTED;
	    },
	
	    /**
	     * Adds reactions to the promise.
	     *
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callbacks execution
	     * @returns {vow:Promise} A new promise, see https://github.com/promises-aplus/promises-spec for details
	     */
	    then : function(onFulfilled, onRejected, onProgress, ctx) {
	        var defer = new Deferred();
	        this._addCallbacks(defer, onFulfilled, onRejected, onProgress, ctx);
	        return defer.promise();
	    },
	
	    /**
	     * Adds only a rejection reaction. This method is a shorthand for `promise.then(undefined, onRejected)`.
	     *
	     * @param {Function} onRejected Callback that will be called with a provided 'reason' as argument after the promise has been rejected
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    'catch' : function(onRejected, ctx) {
	        return this.then(undef, onRejected, ctx);
	    },
	
	    /**
	     * Adds only a rejection reaction. This method is a shorthand for `promise.then(null, onRejected)`. It's also an alias for `catch`.
	     *
	     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    fail : function(onRejected, ctx) {
	        return this.then(undef, onRejected, ctx);
	    },
	
	    /**
	     * Adds a resolving reaction (for both fulfillment and rejection).
	     *
	     * @param {Function} onResolved Callback that will be invoked with the promise as an argument, after the promise has been resolved.
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    always : function(onResolved, ctx) {
	        var _this = this,
	            cb = function() {
	                return onResolved.call(this, _this);
	            };
	
	        return this.then(cb, cb, ctx);
	    },
	
	    /**
	     * Adds a progress reaction.
	     *
	     * @param {Function} onProgress Callback that will be called with a provided value when the promise has been notified
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    progress : function(onProgress, ctx) {
	        return this.then(undef, undef, onProgress, ctx);
	    },
	
	    /**
	     * Like `promise.then`, but "spreads" the array into a variadic value handler.
	     * It is useful with the `vow.all` and the `vow.allResolved` methods.
	     *
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Object} [ctx] Context of the callbacks execution
	     * @returns {vow:Promise}
	     *
	     * @example
	     * ```js
	     * var defer1 = vow.defer(),
	     *     defer2 = vow.defer();
	     *
	     * vow.all([defer1.promise(), defer2.promise()]).spread(function(arg1, arg2) {
	     *     // arg1 is "1", arg2 is "'two'" here
	     * });
	     *
	     * defer1.resolve(1);
	     * defer2.resolve('two');
	     * ```
	     */
	    spread : function(onFulfilled, onRejected, ctx) {
	        return this.then(
	            function(val) {
	                return onFulfilled.apply(this, val);
	            },
	            onRejected,
	            ctx);
	    },
	
	    /**
	     * Like `then`, but terminates a chain of promises.
	     * If the promise has been rejected, this method throws it's "reason" as an exception in a future turn of the event loop.
	     *
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callbacks execution
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer();
	     * defer.reject(Error('Internal error'));
	     * defer.promise().done(); // exception to be thrown
	     * ```
	     */
	    done : function(onFulfilled, onRejected, onProgress, ctx) {
	        this
	            .then(onFulfilled, onRejected, onProgress, ctx)
	            .fail(throwException);
	    },
	
	    /**
	     * Returns a new promise that will be fulfilled in `delay` milliseconds if the promise is fulfilled,
	     * or immediately rejected if the promise is rejected.
	     *
	     * @param {Number} delay
	     * @returns {vow:Promise}
	     */
	    delay : function(delay) {
	        var timer,
	            promise = this.then(function(val) {
	                var defer = new Deferred();
	                timer = setTimeout(
	                    function() {
	                        defer.resolve(val);
	                    },
	                    delay);
	
	                return defer.promise();
	            });
	
	        promise.always(function() {
	            clearTimeout(timer);
	        });
	
	        return promise;
	    },
	
	    /**
	     * Returns a new promise that will be rejected in `timeout` milliseconds
	     * if the promise is not resolved beforehand.
	     *
	     * @param {Number} timeout
	     * @returns {vow:Promise}
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer(),
	     *     promiseWithTimeout1 = defer.promise().timeout(50),
	     *     promiseWithTimeout2 = defer.promise().timeout(200);
	     *
	     * setTimeout(
	     *     function() {
	     *         defer.resolve('ok');
	     *     },
	     *     100);
	     *
	     * promiseWithTimeout1.fail(function(reason) {
	     *     // promiseWithTimeout to be rejected in 50ms
	     * });
	     *
	     * promiseWithTimeout2.then(function(value) {
	     *     // promiseWithTimeout to be fulfilled with "'ok'" value
	     * });
	     * ```
	     */
	    timeout : function(timeout) {
	        var defer = new Deferred(),
	            timer = setTimeout(
	                function() {
	                    defer.reject(new vow.TimedOutError('timed out'));
	                },
	                timeout);
	
	        this.then(
	            function(val) {
	                defer.resolve(val);
	            },
	            function(reason) {
	                defer.reject(reason);
	            });
	
	        defer.promise().always(function() {
	            clearTimeout(timer);
	        });
	
	        return defer.promise();
	    },
	
	    _vow : true,
	
	    _resolve : function(val) {
	        if(this._status > PROMISE_STATUS.RESOLVED) {
	            return;
	        }
	
	        if(val === this) {
	            this._reject(TypeError('Can\'t resolve promise with itself'));
	            return;
	        }
	
	        this._status = PROMISE_STATUS.RESOLVED;
	
	        if(val && !!val._vow) { // shortpath for vow.Promise
	            val.isFulfilled()?
	                this._fulfill(val.valueOf()) :
	                val.isRejected()?
	                    this._reject(val.valueOf()) :
	                    val.then(
	                        this._fulfill,
	                        this._reject,
	                        this._notify,
	                        this);
	            return;
	        }
	
	        if(isObject(val) || isFunction(val)) {
	            var then;
	            try {
	                then = val.then;
	            }
	            catch(e) {
	                this._reject(e);
	                return;
	            }
	
	            if(isFunction(then)) {
	                var _this = this,
	                    isResolved = false;
	
	                try {
	                    then.call(
	                        val,
	                        function(val) {
	                            if(isResolved) {
	                                return;
	                            }
	
	                            isResolved = true;
	                            _this._resolve(val);
	                        },
	                        function(err) {
	                            if(isResolved) {
	                                return;
	                            }
	
	                            isResolved = true;
	                            _this._reject(err);
	                        },
	                        function(val) {
	                            _this._notify(val);
	                        });
	                }
	                catch(e) {
	                    isResolved || this._reject(e);
	                }
	
	                return;
	            }
	        }
	
	        this._fulfill(val);
	    },
	
	    _fulfill : function(val) {
	        if(this._status > PROMISE_STATUS.RESOLVED) {
	            return;
	        }
	
	        this._status = PROMISE_STATUS.FULFILLED;
	        this._value = val;
	
	        this._callCallbacks(this._fulfilledCallbacks, val);
	        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
	    },
	
	    _reject : function(reason) {
	        if(this._status > PROMISE_STATUS.RESOLVED) {
	            return;
	        }
	
	        this._status = PROMISE_STATUS.REJECTED;
	        this._value = reason;
	
	        this._callCallbacks(this._rejectedCallbacks, reason);
	        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
	    },
	
	    _notify : function(val) {
	        this._callCallbacks(this._progressCallbacks, val);
	    },
	
	    _addCallbacks : function(defer, onFulfilled, onRejected, onProgress, ctx) {
	        if(onRejected && !isFunction(onRejected)) {
	            ctx = onRejected;
	            onRejected = undef;
	        }
	        else if(onProgress && !isFunction(onProgress)) {
	            ctx = onProgress;
	            onProgress = undef;
	        }
	
	        var cb;
	
	        if(!this.isRejected()) {
	            cb = { defer : defer, fn : isFunction(onFulfilled)? onFulfilled : undef, ctx : ctx };
	            this.isFulfilled()?
	                this._callCallbacks([cb], this._value) :
	                this._fulfilledCallbacks.push(cb);
	        }
	
	        if(!this.isFulfilled()) {
	            cb = { defer : defer, fn : onRejected, ctx : ctx };
	            this.isRejected()?
	                this._callCallbacks([cb], this._value) :
	                this._rejectedCallbacks.push(cb);
	        }
	
	        if(this._status <= PROMISE_STATUS.RESOLVED) {
	            this._progressCallbacks.push({ defer : defer, fn : onProgress, ctx : ctx });
	        }
	    },
	
	    _callCallbacks : function(callbacks, arg) {
	        var len = callbacks.length;
	        if(!len) {
	            return;
	        }
	
	        var isResolved = this.isResolved(),
	            isFulfilled = this.isFulfilled(),
	            isRejected = this.isRejected();
	
	        nextTick(function() {
	            var i = 0, cb, defer, fn;
	            while(i < len) {
	                cb = callbacks[i++];
	                defer = cb.defer;
	                fn = cb.fn;
	
	                if(fn) {
	                    var ctx = cb.ctx,
	                        res;
	                    try {
	                        res = ctx? fn.call(ctx, arg) : fn(arg);
	                    }
	                    catch(e) {
	                        defer.reject(e);
	                        continue;
	                    }
	
	                    isResolved?
	                        defer.resolve(res) :
	                        defer.notify(res);
	                }
	                else if(isFulfilled) {
	                    defer.resolve(arg);
	                }
	                else if(isRejected) {
	                    defer.reject(arg);
	                }
	                else {
	                    defer.notify(arg);
	                }
	            }
	        });
	    }
	};
	
	/** @lends Promise */
	var staticMethods = {
	    /**
	     * Coerces the given `value` to a promise, or returns the `value` if it's already a promise.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    cast : function(value) {
	        return vow.cast(value);
	    },
	
	    /**
	     * Returns a promise, that will be fulfilled only after all the items in `iterable` are fulfilled.
	     * If any of the `iterable` items gets rejected, then the returned promise will be rejected.
	     *
	     * @param {Array|Object} iterable
	     * @returns {vow:Promise}
	     */
	    all : function(iterable) {
	        return vow.all(iterable);
	    },
	
	    /**
	     * Returns a promise, that will be fulfilled only when any of the items in `iterable` are fulfilled.
	     * If any of the `iterable` items gets rejected, then the returned promise will be rejected.
	     *
	     * @param {Array} iterable
	     * @returns {vow:Promise}
	     */
	    race : function(iterable) {
	        return vow.anyResolved(iterable);
	    },
	
	    /**
	     * Returns a promise that has already been resolved with the given `value`.
	     * If `value` is a promise, the returned promise will have `value`'s state.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    resolve : function(value) {
	        return vow.resolve(value);
	    },
	
	    /**
	     * Returns a promise that has already been rejected with the given `reason`.
	     *
	     * @param {*} reason
	     * @returns {vow:Promise}
	     */
	    reject : function(reason) {
	        return vow.reject(reason);
	    }
	};
	
	for(var prop in staticMethods) {
	    staticMethods.hasOwnProperty(prop) &&
	        (Promise[prop] = staticMethods[prop]);
	}
	
	var vow = /** @exports vow */ {
	    Deferred : Deferred,
	
	    Promise : Promise,
	
	    /**
	     * Creates a new deferred. This method is a factory method for `vow:Deferred` class.
	     * It's equivalent to `new vow.Deferred()`.
	     *
	     * @returns {vow:Deferred}
	     */
	    defer : function() {
	        return new Deferred();
	    },
	
	    /**
	     * Static equivalent to `promise.then`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callbacks execution
	     * @returns {vow:Promise}
	     */
	    when : function(value, onFulfilled, onRejected, onProgress, ctx) {
	        return vow.cast(value).then(onFulfilled, onRejected, onProgress, ctx);
	    },
	
	    /**
	     * Static equivalent to `promise.fail`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} onRejected Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    fail : function(value, onRejected, ctx) {
	        return vow.when(value, undef, onRejected, ctx);
	    },
	
	    /**
	     * Static equivalent to `promise.always`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} onResolved Callback that will be invoked with the promise as an argument, after the promise has been resolved.
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    always : function(value, onResolved, ctx) {
	        return vow.when(value).always(onResolved, ctx);
	    },
	
	    /**
	     * Static equivalent to `promise.progress`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} onProgress Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    progress : function(value, onProgress, ctx) {
	        return vow.when(value).progress(onProgress, ctx);
	    },
	
	    /**
	     * Static equivalent to `promise.spread`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Object} [ctx] Context of the callbacks execution
	     * @returns {vow:Promise}
	     */
	    spread : function(value, onFulfilled, onRejected, ctx) {
	        return vow.when(value).spread(onFulfilled, onRejected, ctx);
	    },
	
	    /**
	     * Static equivalent to `promise.done`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callbacks execution
	     */
	    done : function(value, onFulfilled, onRejected, onProgress, ctx) {
	        vow.when(value).done(onFulfilled, onRejected, onProgress, ctx);
	    },
	
	    /**
	     * Checks whether the given `value` is a promise-like object
	     *
	     * @param {*} value
	     * @returns {Boolean}
	     *
	     * @example
	     * ```js
	     * vow.isPromise('something'); // returns false
	     * vow.isPromise(vow.defer().promise()); // returns true
	     * vow.isPromise({ then : function() { }); // returns true
	     * ```
	     */
	    isPromise : function(value) {
	        return isObject(value) && isFunction(value.then);
	    },
	
	    /**
	     * Coerces the given `value` to a promise, or returns the `value` if it's already a promise.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    cast : function(value) {
	        return value && !!value._vow?
	            value :
	            vow.resolve(value);
	    },
	
	    /**
	     * Static equivalent to `promise.valueOf`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @returns {*}
	     */
	    valueOf : function(value) {
	        return value && isFunction(value.valueOf)? value.valueOf() : value;
	    },
	
	    /**
	     * Static equivalent to `promise.isFulfilled`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @returns {Boolean}
	     */
	    isFulfilled : function(value) {
	        return value && isFunction(value.isFulfilled)? value.isFulfilled() : true;
	    },
	
	    /**
	     * Static equivalent to `promise.isRejected`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @returns {Boolean}
	     */
	    isRejected : function(value) {
	        return value && isFunction(value.isRejected)? value.isRejected() : false;
	    },
	
	    /**
	     * Static equivalent to `promise.isResolved`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @returns {Boolean}
	     */
	    isResolved : function(value) {
	        return value && isFunction(value.isResolved)? value.isResolved() : true;
	    },
	
	    /**
	     * Returns a promise that has already been resolved with the given `value`.
	     * If `value` is a promise, the returned promise will have `value`'s state.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    resolve : function(value) {
	        var res = vow.defer();
	        res.resolve(value);
	        return res.promise();
	    },
	
	    /**
	     * Returns a promise that has already been fulfilled with the given `value`.
	     * If `value` is a promise, the returned promise will be fulfilled with the fulfill/rejection value of `value`.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    fulfill : function(value) {
	        var defer = vow.defer(),
	            promise = defer.promise();
	
	        defer.resolve(value);
	
	        return promise.isFulfilled()?
	            promise :
	            promise.then(null, function(reason) {
	                return reason;
	            });
	    },
	
	    /**
	     * Returns a promise that has already been rejected with the given `reason`.
	     * If `reason` is a promise, the returned promise will be rejected with the fulfill/rejection value of `reason`.
	     *
	     * @param {*} reason
	     * @returns {vow:Promise}
	     */
	    reject : function(reason) {
	        var defer = vow.defer();
	        defer.reject(reason);
	        return defer.promise();
	    },
	
	    /**
	     * Invokes the given function `fn` with arguments `args`
	     *
	     * @param {Function} fn
	     * @param {...*} [args]
	     * @returns {vow:Promise}
	     *
	     * @example
	     * ```js
	     * var promise1 = vow.invoke(function(value) {
	     *         return value;
	     *     }, 'ok'),
	     *     promise2 = vow.invoke(function() {
	     *         throw Error();
	     *     });
	     *
	     * promise1.isFulfilled(); // true
	     * promise1.valueOf(); // 'ok'
	     * promise2.isRejected(); // true
	     * promise2.valueOf(); // instance of Error
	     * ```
	     */
	    invoke : function(fn, args) {
	        var len = Math.max(arguments.length - 1, 0),
	            callArgs;
	        if(len) { // optimization for V8
	            callArgs = Array(len);
	            var i = 0;
	            while(i < len) {
	                callArgs[i++] = arguments[i];
	            }
	        }
	
	        try {
	            return vow.resolve(callArgs?
	                fn.apply(global, callArgs) :
	                fn.call(global));
	        }
	        catch(e) {
	            return vow.reject(e);
	        }
	    },
	
	    /**
	     * Returns a promise, that will be fulfilled only after all the items in `iterable` are fulfilled.
	     * If any of the `iterable` items gets rejected, the promise will be rejected.
	     *
	     * @param {Array|Object} iterable
	     * @returns {vow:Promise}
	     *
	     * @example
	     * with array:
	     * ```js
	     * var defer1 = vow.defer(),
	     *     defer2 = vow.defer();
	     *
	     * vow.all([defer1.promise(), defer2.promise(), 3])
	     *     .then(function(value) {
	     *          // value is "[1, 2, 3]" here
	     *     });
	     *
	     * defer1.resolve(1);
	     * defer2.resolve(2);
	     * ```
	     *
	     * @example
	     * with object:
	     * ```js
	     * var defer1 = vow.defer(),
	     *     defer2 = vow.defer();
	     *
	     * vow.all({ p1 : defer1.promise(), p2 : defer2.promise(), p3 : 3 })
	     *     .then(function(value) {
	     *          // value is "{ p1 : 1, p2 : 2, p3 : 3 }" here
	     *     });
	     *
	     * defer1.resolve(1);
	     * defer2.resolve(2);
	     * ```
	     */
	    all : function(iterable) {
	        var defer = new Deferred(),
	            isPromisesArray = isArray(iterable),
	            keys = isPromisesArray?
	                getArrayKeys(iterable) :
	                getObjectKeys(iterable),
	            len = keys.length,
	            res = isPromisesArray? [] : {};
	
	        if(!len) {
	            defer.resolve(res);
	            return defer.promise();
	        }
	
	        var i = len;
	        vow._forEach(
	            iterable,
	            function(value, idx) {
	                res[keys[idx]] = value;
	                if(!--i) {
	                    defer.resolve(res);
	                }
	            },
	            defer.reject,
	            defer.notify,
	            defer,
	            keys);
	
	        return defer.promise();
	    },
	
	    /**
	     * Returns a promise, that will be fulfilled only after all the items in `iterable` are resolved.
	     *
	     * @param {Array|Object} iterable
	     * @returns {vow:Promise}
	     *
	     * @example
	     * ```js
	     * var defer1 = vow.defer(),
	     *     defer2 = vow.defer();
	     *
	     * vow.allResolved([defer1.promise(), defer2.promise()]).spread(function(promise1, promise2) {
	     *     promise1.isRejected(); // returns true
	     *     promise1.valueOf(); // returns "'error'"
	     *     promise2.isFulfilled(); // returns true
	     *     promise2.valueOf(); // returns "'ok'"
	     * });
	     *
	     * defer1.reject('error');
	     * defer2.resolve('ok');
	     * ```
	     */
	    allResolved : function(iterable) {
	        var defer = new Deferred(),
	            isPromisesArray = isArray(iterable),
	            keys = isPromisesArray?
	                getArrayKeys(iterable) :
	                getObjectKeys(iterable),
	            i = keys.length,
	            res = isPromisesArray? [] : {};
	
	        if(!i) {
	            defer.resolve(res);
	            return defer.promise();
	        }
	
	        var onResolved = function() {
	                --i || defer.resolve(iterable);
	            };
	
	        vow._forEach(
	            iterable,
	            onResolved,
	            onResolved,
	            defer.notify,
	            defer,
	            keys);
	
	        return defer.promise();
	    },
	
	    allPatiently : function(iterable) {
	        return vow.allResolved(iterable).then(function() {
	            var isPromisesArray = isArray(iterable),
	                keys = isPromisesArray?
	                    getArrayKeys(iterable) :
	                    getObjectKeys(iterable),
	                rejectedPromises, fulfilledPromises,
	                len = keys.length, i = 0, key, promise;
	
	            if(!len) {
	                return isPromisesArray? [] : {};
	            }
	
	            while(i < len) {
	                key = keys[i++];
	                promise = iterable[key];
	                if(vow.isRejected(promise)) {
	                    rejectedPromises || (rejectedPromises = isPromisesArray? [] : {});
	                    isPromisesArray?
	                        rejectedPromises.push(promise.valueOf()) :
	                        rejectedPromises[key] = promise.valueOf();
	                }
	                else if(!rejectedPromises) {
	                    (fulfilledPromises || (fulfilledPromises = isPromisesArray? [] : {}))[key] = vow.valueOf(promise);
	                }
	            }
	
	            if(rejectedPromises) {
	                throw rejectedPromises;
	            }
	
	            return fulfilledPromises;
	        });
	    },
	
	    /**
	     * Returns a promise, that will be fulfilled if any of the items in `iterable` is fulfilled.
	     * If all of the `iterable` items get rejected, the promise will be rejected (with the reason of the first rejected item).
	     *
	     * @param {Array} iterable
	     * @returns {vow:Promise}
	     */
	    any : function(iterable) {
	        var defer = new Deferred(),
	            len = iterable.length;
	
	        if(!len) {
	            defer.reject(Error());
	            return defer.promise();
	        }
	
	        var i = 0, reason;
	        vow._forEach(
	            iterable,
	            defer.resolve,
	            function(e) {
	                i || (reason = e);
	                ++i === len && defer.reject(reason);
	            },
	            defer.notify,
	            defer);
	
	        return defer.promise();
	    },
	
	    /**
	     * Returns a promise, that will be fulfilled only when any of the items in `iterable` is fulfilled.
	     * If any of the `iterable` items gets rejected, the promise will be rejected.
	     *
	     * @param {Array} iterable
	     * @returns {vow:Promise}
	     */
	    anyResolved : function(iterable) {
	        var defer = new Deferred(),
	            len = iterable.length;
	
	        if(!len) {
	            defer.reject(Error());
	            return defer.promise();
	        }
	
	        vow._forEach(
	            iterable,
	            defer.resolve,
	            defer.reject,
	            defer.notify,
	            defer);
	
	        return defer.promise();
	    },
	
	    /**
	     * Static equivalent to `promise.delay`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Number} delay
	     * @returns {vow:Promise}
	     */
	    delay : function(value, delay) {
	        return vow.resolve(value).delay(delay);
	    },
	
	    /**
	     * Static equivalent to `promise.timeout`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Number} timeout
	     * @returns {vow:Promise}
	     */
	    timeout : function(value, timeout) {
	        return vow.resolve(value).timeout(timeout);
	    },
	
	    _forEach : function(promises, onFulfilled, onRejected, onProgress, ctx, keys) {
	        var len = keys? keys.length : promises.length,
	            i = 0;
	
	        while(i < len) {
	            vow.when(
	                promises[keys? keys[i] : i],
	                wrapOnFulfilled(onFulfilled, i),
	                onRejected,
	                onProgress,
	                ctx);
	            ++i;
	        }
	    },
	
	    TimedOutError : defineCustomErrorType('TimedOut')
	};
	
	var defineAsGlobal = true;
	if(typeof module === 'object' && typeof module.exports === 'object') {
	    module.exports = vow;
	    defineAsGlobal = false;
	}
	
	if(typeof modules === 'object' && isFunction(modules.define)) {
	    modules.define('vow', function(provide) {
	        provide(vow);
	    });
	    defineAsGlobal = false;
	}
	
	if(true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	        module.exports = vow;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    defineAsGlobal = false;
	}
	
	defineAsGlobal && (global.vow = vow);
	
	})(typeof window !== 'undefined'? window : global);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(12).setImmediate, __webpack_require__(13)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(13).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12).setImmediate, __webpack_require__(12).clearImmediate))

/***/ },
/* 13 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it don't break things.
	var cachedSetTimeout = setTimeout;
	var cachedClearTimeout = clearTimeout;
	
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var Fasta, extend, st;
	
	  st = __webpack_require__(15);
	
	  extend = __webpack_require__(16);
	
	  module.exports = Fasta = {
	    getMeta: st.getMeta,
	    extend: function(metaParser) {
	      var customFasta;
	      customFasta = extend(Fasta);
	      Fasta.getMeta = metaParser;
	      return customFasta;
	    },
	    parse: function(text) {
	      var currentSeq, getMeta, i, id, label, len, line, obj, seqs;
	      seqs = [];
	      if (!text || text.length === 0) {
	        return [];
	      }
	      if (Object.prototype.toString.call(text) !== '[object Array]') {
	        text = text.split("\n");
	      }
	      getMeta = Fasta.getMeta;
	      for (i = 0, len = text.length; i < len; i++) {
	        line = text[i];
	        if (line[0] === ">" || line[0] === ";") {
	          label = line.slice(1);
	          obj = getMeta(label);
	          label = obj.name;
	          id = obj.id || seqs.length;
	          currentSeq = new st.model("", obj.name, id);
	          currentSeq.ids = obj.ids || {};
	          currentSeq.details = obj.details || {};
	          seqs.push(currentSeq);
	        } else {
	          currentSeq.seq += line;
	        }
	      }
	      return seqs;
	    },
	    write: function(seqs, access) {
	      var i, len, seq, text;
	      text = "";
	      for (i = 0, len = seqs.length; i < len; i++) {
	        seq = seqs[i];
	        if (access != null) {
	          seq = access(seq);
	        }
	        text += ">" + seq.name + "\n";
	        text += (st.splitNChars(seq.seq, 80)).join("\n");
	        text += "\n";
	      }
	      return text;
	    }
	  };
	
	}).call(this);


/***/ },
/* 15 */
/***/ function(module, exports) {

	/*
	 * msa-seqtools
	 * https://github.com/greenify/msa-seqtools
	 *
	 * Copyright (c) 2014 greenify
	 * Licensed under the MIT license.
	 */
	
	var st = {};
	module.exports = st;
	
	/****
	 * Seems to be lots of different ways to format FASTA headers. 
	 * 
	 * Generally there's an ID and a DESCRIPTION
	 *   >ID DESCRIPTION
	 * 
	 *   >(parts|of|ID) (DESCRIPTION with optional key=values)
	 *   
	 * This is complicated by the fact that the "values" in the description can have spaces
	 * e.g. OS=Arabidopsis thaliana GN=CCD8
	 * 
	 ****
	*/
	
	// extract IDs and push them to the meta dict
	st.getMeta = function(label) {
	  
		var full_id = false, full_desc = false;
		var name, ids = {}, details = {}, description;
	
	// 	console.log( "getMeta.label: ", label );
	  
		var label_parts = label.split(" ");
	
		if ( label_parts.length >= 1 ) {
			full_id   = label_parts.shift();     // everything up to the first white space
			full_desc = label_parts.join(" ");   // everything else
		}
		else {
			full_id = label; 
		}
		
	// 	console.log( "full_id", full_id );
	// 	console.log( "full_desc", full_desc );
		
		if ( full_id ) {
			var id_parts = full_id.split('|');
			
			// the last item is the accession
			name = id_parts.pop(); 
			
			details.en = name;
			
			// everything else should be pairs: db|id
			while ( id_parts.length != 0 ) {
				var db = id_parts.shift();
				var id = id_parts.shift();
				ids[ db ] = id;
			}
		}
		else {
			name = full_id;
		}
	
		if ( full_desc ) {
		
			var kv_parts = full_desc.split('=');
		
			if ( kv_parts.length > 1 ) {
				
				var current_key, next_key;
				var kv;
				var kv_idx_max = kv_parts.length - 1;
				var kv_idx = 0;
				kv_parts.forEach( function( value_and_maybe_next_key ) {
					
					value_and_maybe_next_key = value_and_maybe_next_key.trim();
					
					var value_parts = value_and_maybe_next_key.split(" ");
					var value;
					if ( value_parts.length > 1 ) {
						next_key = value_parts.pop();
						value = value_parts.join(' ');
					}
					else {
						value = value_and_maybe_next_key;
					}
	
					if ( current_key ) {
						var key = current_key.toLowerCase();
						details[ key ] = value;
						//console.log( "details[" + key + "] = " + value );
					}
					else {
						description = value;
						//console.log( "description=" + value );
					}
					current_key = next_key;
				});
			}
			else {
				description = kv_parts.shift();
			}
		}
		
		var meta = {
			name: name,
			ids: ids,
			details: details,
		};
		
		if ( description ) {
			meta.desc = description
		}
		
	// 	console.log( "meta", meta );
		
		return meta;
	};
	
	var findSepInArr = function(arr, sep) {
	  for (var i = 0; i < arr.lenght; i++) {
	    if (arr[i].indexOf(i)) {
	      return i;
	    }
	  }
	  return arr.length - 1;
	};
	
	var strToDict = function(str, sep, toJoin) {
	  toJoin = toJoin || {};
	  var entries = str.split(sep);
	  toJoin[entries[0].toLowerCase()] = entries[1];
	  return toJoin;
	};
	
	var identDB = {
	  "sp": {
	    link: "http://www.uniprot.org/%s",
	    name: "Uniprot"
	  },
	  "tr": {
	    link: "http://www.uniprot.org/%s",
	    name: "Trembl"
	  },
	  "gb": {
	    link: "http://www.ncbi.nlm.nih.gov/nuccore/%s",
	    name: "Genbank"
	  },
	  "pdb": {
	    link: "http://www.rcsb.org/pdb/explore/explore.do?structureId=%s",
	    name: "PDB"
	  }
	};
	
	st.buildLinks = function(meta) {
	  var links = {};
	  meta = meta || {};
	  Object.keys(meta).forEach(function(id) {
	    if (id in identDB) {
	      var entry = identDB[id];
	      var link = entry.link.replace("%s", meta[id]);
	      links[entry.name] = link;
	    }
	  });
	  return links;
	};
	
	
	// search for a text
	st.contains = function(text, search) {
	  return ''.indexOf.call(text, search, 0) !== -1;
	};
	
	// split after e.g. 80 chars
	st.splitNChars = function(txt, num) {
	  var i, _ref;
	  num = num || 80;
	  var result = [];
	  for (i = 0, _ref = txt.length - 1; i <= _ref; i += num) {
	    result.push(txt.substr(i, num));
	  }
	  return result;
	};
	
	st.reverse = function(seq) {
	  return seq.split('').reverse().join('');
	}
	
	st.complement = function(seq) {
	  var newSeq = seq + "";
	  var replacements = [
	    // cg
	    [/g/g, "0"],
	    [/c/g, "1"],
	    [/0/g, "c"],
	    [/1/g, "g"],
	    // CG
	    [/G/g, "0"],
	    [/C/g, "1"],
	    [/0/g, "C"],
	    [/1/g, "G"],
	    // at
	    [/a/g, "0"],
	    [/t/g, "1"],
	    [/0/g, "t"],
	    [/1/g, "a"],
	    // AT
	    [/A/g, "0"],
	    [/T/g, "1"],
	    [/0/g, "T"],
	    [/1/g, "A"],
	  ];
	
	  for(var rep in replacements){
	    newSeq = newSeq.replace(replacements[rep][0], replacements[rep][1]);
	  }
	  return newSeq;
	}
	
	st.reverseComplement = function(seq){
	  return st.reverse(st.complement(seq));
	}
	
	st.model = function Seq(seq, name, id) {
	  this.seq = seq;
	  this.name = name;
	  this.id = id;
	  this.ids = {};
	};


/***/ },
/* 16 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  module.exports = function(out) {
	    var i, j, k, key, len, ref, ref1;
	    out = out || {};
	    for (i = j = 0, ref = arguments.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      if (!arguments[i]) {
	        continue;
	      }
	      ref1 = arguments[i];
	      for (k = 0, len = ref1.length; k < len; k++) {
	        key = ref1[k];
	        if (arguments[i].hasOwnProperty(key)) {
	          out[key] = arguments[i][key];
	        }
	      }
	    }
	    return out;
	  };
	
	}).call(this);


/***/ }
/******/ ]);
//# sourceMappingURL=fasta_bundle.js.map